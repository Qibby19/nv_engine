#!/usr/bin/env python3

import os
import sys
import argparse
import hashlib
import re
import math
from pathlib import Path
from collections import Counter
import json

try:
    import yara
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False
    print("Warning: YARA not installed. Install with: pip install yara-python")

class AIGeneratedDetector:
    """Simple ML-based detector for AI-generated content patterns"""
    
    def __init__(self):
        # AI-generated code often has these characteristics
        self.ai_patterns = [
            r'# This is a comment explaining the code',
            r'def main\(\):',
            r'if __name__ == "__main__":',
            r'# Import necessary libraries',
            r'# Function to \w+',
            r'# Loop through \w+',
            r'# Check if \w+',
            r'import \w+\nimport \w+\nimport \w+',
            r'This demonstrates',
            r'Method to \w+',
            r'Function to \w+',
            r'class \w+Manager',
            r'class \w+Handler',
            r'class \w+Gatherer',
            r'def \w+_\w+_\w+\(',
            r'def collect_\w+\(',
            r'def generate_\w+\(',
            r'def simulate_\w+\(',
            r'\[INFO\]',
            r'\[ERROR\]',
            r'\[STAGE'
        ]
        
        # Suspicious entropy patterns (AI often generates certain patterns)
        self.entropy_threshold_low = 4.0
        self.entropy_threshold_high = 5.5
        
    def calculate_entropy(self, data):
        """Calculate Shannon entropy of data"""
        if not data:
            return 0
        
        # Count frequency of each byte
        byte_counts = Counter(data)
        total_bytes = len(data)
        
        # Calculate entropy
        entropy = 0
        for count in byte_counts.values():
            p = count / total_bytes
            if p > 0:
                entropy -= p * math.log2(p)
        
        return entropy
    
    def detect_ai_patterns(self, content):
        """Detect common AI-generated code patterns"""
        if isinstance(content, bytes):
            try:
                content = content.decode('utf-8', errors='ignore')
            except:
                return 0.0
        
        pattern_matches = 0
        total_patterns = len(self.ai_patterns)
        
        for pattern in self.ai_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                pattern_matches += 1
        
        return pattern_matches / total_patterns if total_patterns > 0 else 0.0
    
    def analyze_structure(self, content):
        """Analyze code structure for AI-generated characteristics"""
        if isinstance(content, bytes):
            try:
                content = content.decode('utf-8', errors='ignore')
            except:
                return 0.0
        
        suspicion_score = 0.0
        
        # Check for excessive comments (AI often over-comments)
        lines = content.split('\n')
        comment_ratio = sum(1 for line in lines if line.strip().startswith('#')) / max(len(lines), 1)
        if comment_ratio > 0.3:
            suspicion_score += 0.3
        
        # Check for repetitive patterns
        words = re.findall(r'\w+', content.lower())
        if len(words) > 0:
            unique_words = len(set(words))
            repetition_ratio = 1 - (unique_words / len(words))
            if repetition_ratio > 0.7:
                suspicion_score += 0.4
        
        # Check for typical AI function naming patterns
        ai_function_patterns = [
            r'def process_\w+\(',
            r'def handle_\w+\(',
            r'def calculate_\w+\(',
            r'def get_\w+_data\(',
            r'def collect_\w+\(',
            r'def generate_\w+\(',
            r'def simulate_\w+\(',
            r'def \w+_\w+_\w+\('  # verb_noun_noun pattern
        ]
        
        function_matches = 0
        for pattern in ai_function_patterns:
            function_matches += len(re.findall(pattern, content))
        
        if function_matches > 3:
            suspicion_score += 0.4
            
        # Check for AI-style class names
        ai_class_patterns = [
            r'class \w+Manager',
            r'class \w+Handler', 
            r'class \w+Gatherer',
            r'class \w+Communicator'
        ]
        
        class_matches = 0
        for pattern in ai_class_patterns:
            class_matches += len(re.findall(pattern, content))
            
        if class_matches > 0:
            suspicion_score += 0.3
            
        # Check for excessive imports (AI often imports many libraries)
        import_lines = len([line for line in content.split('\n') 
                           if line.strip().startswith('import ') or 
                           line.strip().startswith('from ')])
        if import_lines > 8:
            suspicion_score += 0.2
        
        return min(suspicion_score, 1.0)
    
    def detect(self, file_path):
        """Main detection method"""
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
            
            # Calculate entropy
            entropy = self.calculate_entropy(content)
            entropy_suspicious = (self.entropy_threshold_low <= entropy <= self.entropy_threshold_high)
            
            # Detect AI patterns
            pattern_score = self.detect_ai_patterns(content)
            
            # Analyze structure
            structure_score = self.analyze_structure(content)
            
            # Combine scores with adjusted weights
            combined_score = (pattern_score * 0.5 + structure_score * 0.3 + 
                            (0.2 if entropy_suspicious else 0.0))
            
            return {
                'suspicious': combined_score > 0.4,  # Lowered threshold
                'confidence': combined_score,
                'entropy': entropy,
                'pattern_score': pattern_score,
                'structure_score': structure_score
            }
            
        except Exception as e:
            return {'error': str(e)}

class YARADetector:
    """YARA-based malware detection"""
    
    def __init__(self):
        # Basic YARA rules for common malware patterns
        self.rules_content = '''
        rule SuspiciousStrings {
            meta:
                description = "Detects suspicious strings commonly found in malware"
                author = "Malware Detector"
            strings:
                $s1 = "cmd.exe" nocase
                $s2 = "powershell" nocase
                $s3 = "rundll32" nocase
                $s4 = "CreateRemoteThread" nocase
                $s5 = "VirtualAlloc" nocase
                $s6 = "WriteProcessMemory" nocase
                $s7 = "GetProcAddress" nocase
                $s8 = "LoadLibrary" nocase
                $s9 = /eval\\s*\\(/
                $s10 = "base64_decode" nocase
                $s11 = "shell_exec" nocase
                $s12 = "system(" nocase
            condition:
                any of them
        }
        
        rule NetworkActivity {
            meta:
                description = "Detects potential network-based malware"
            strings:
                $n1 = "socket"
                $n2 = "connect"
                $n3 = "recv"
                $n4 = "send"
                $n5 = "urllib" nocase
                $n6 = "requests" nocase
                $n7 = "http://" nocase
                $n8 = "https://" nocase
            condition:
                3 of them
        }
        
        rule Obfuscation {
            meta:
                description = "Detects code obfuscation techniques"
            strings:
                $o1 = /\\\\x[0-9a-fA-F]{2}/
                $o2 = /[A-Za-z0-9+\/]{50,}/
                $o3 = "chr("
                $o4 = "ord("
                $o5 = "exec("
                $o6 = "eval("
            condition:
                2 of them
        }
        '''
        
        self.rules = None
        if YARA_AVAILABLE:
            try:
                self.rules = yara.compile(source=self.rules_content)
            except Exception as e:
                print(f"Error compiling YARA rules: {e}")
                self.rules = None
    
    def scan(self, file_path):
        """Scan file with YARA rules"""
        if not self.rules:
            return []
        
        try:
            matches = self.rules.match(file_path)
            return [{'rule': match.rule, 'meta': match.meta} for match in matches]
        except Exception as e:
            return [{'error': str(e)}]

class MalwareDetector:
    """Main malware detector class"""
    
    def __init__(self):
        self.ai_detector = AIGeneratedDetector()
        self.yara_detector = YARADetector()
        self.scanned_files = 0
        self.detected_files = 0
        self.suspicious_files = 0
    
    def is_scannable_file(self, file_path):
        """Check if file should be scanned"""
        # Skip binary files that are unlikely to contain malware code
        skip_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.pdf', '.mp4', '.mp3', 
                          '.zip', '.tar', '.gz', '.iso', '.img'}
        
        file_extension = Path(file_path).suffix.lower()
        return file_extension not in skip_extensions
    
    def scan_file(self, file_path):
        """Scan individual file"""
        if not self.is_scannable_file(file_path):
            return None
        
        try:
            file_size = os.path.getsize(file_path)
            if file_size == 0 or file_size > 10 * 1024 * 1024:  # Skip empty or very large files
                return None
            
            result = {
                'file_path': str(file_path),
                'status': 'clean',
                'yara_matches': [],
                'ai_analysis': {},
                'explanation': 'File appears clean'
            }
            
            # YARA scan
            yara_matches = self.yara_detector.scan(file_path)
            if yara_matches and not any('error' in match for match in yara_matches):
                result['yara_matches'] = yara_matches
                if yara_matches:
                    result['status'] = 'detected'
                    result['explanation'] = f"YARA detected: {', '.join([m['rule'] for m in yara_matches])}"
                    self.detected_files += 1
            
            # AI analysis (only if not already detected by YARA)
            if result['status'] == 'clean':
                ai_result = self.ai_detector.detect(file_path)
                result['ai_analysis'] = ai_result
                
                if 'error' not in ai_result and ai_result.get('suspicious', False):
                    result['status'] = 'suspicious'
                    confidence = ai_result.get('confidence', 0)
                    result['explanation'] = f"AI-generated patterns detected (confidence: {confidence:.2f})"
                    self.suspicious_files += 1
            
            self.scanned_files += 1
            return result
            
        except Exception as e:
            return {
                'file_path': str(file_path),
                'status': 'error',
                'explanation': f"Error scanning file: {str(e)}"
            }
    
    def scan_directory(self, directory):
        """Recursively scan directory"""
        results = []
        
        print(f"Scanning directory: {directory}")
        print("-" * 60)
        
        for root, dirs, files in os.walk(directory):
            for file in files:
                file_path = Path(root) / file
                result = self.scan_file(file_path)
                
                if result:
                    results.append(result)
                    self.print_result(result)
        
        return results
    
    def print_result(self, result):
        """Print scan result to terminal"""
        status = result['status']
        file_path = result['file_path']
        explanation = result['explanation']
        
        # Color coding for terminal output
        colors = {
            'clean': '\033[92m',      # Green
            'suspicious': '\033[93m', # Yellow
            'detected': '\033[91m',   # Red
            'error': '\033[95m',      # Magenta
            'reset': '\033[0m'        # Reset
        }
        
        color = colors.get(status, colors['reset'])
        
        print(f"{color}[{status.upper()}]{colors['reset']} {file_path}")
        
        if status != 'clean':
            print(f"  └─ {explanation}")
            
            # Print additional details for suspicious files
            if status == 'suspicious' and 'ai_analysis' in result:
                ai_data = result['ai_analysis']
                if 'confidence' in ai_data:
                    print(f"     Confidence: {ai_data['confidence']:.2f}")
                if 'entropy' in ai_data:
                    print(f"     Entropy: {ai_data['entropy']:.2f}")
        
        print()
    
    def print_summary(self):
        """Print scan summary"""
        print("=" * 60)
        print("SCAN SUMMARY")
        print("=" * 60)
        print(f"Files scanned: {self.scanned_files}")
        print(f"Threats detected: {self.detected_files}")
        print(f"Suspicious (AI-generated): {self.suspicious_files}")
        print(f"Clean files: {self.scanned_files - self.detected_files - self.suspicious_files}")

def main():
    parser = argparse.ArgumentParser(description='AI-Generated Malware Detector')
    parser.add_argument('path', help='File or directory path to scan')
    parser.add_argument('--output', '-o', help='Output results to JSON file')
    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    if not os.path.exists(args.path):
        print(f"Error: Path '{args.path}' does not exist")
        sys.exit(1)
    
    # Initialize detector
    detector = MalwareDetector()
    
    print("AI-Generated Malware Detector")
    print("=" * 60)
    
    if not YARA_AVAILABLE:
        print("Warning: YARA not available. Only AI detection will be used.")
        print()
    
    # Scan file or directory
    if os.path.isfile(args.path):
        result = detector.scan_file(args.path)
        if result:
            detector.print_result(result)
            results = [result]
        else:
            results = []
    else:
        results = detector.scan_directory(args.path)
    
    # Print summary
    detector.print_summary()
    
    # Save results to JSON if requested
    if args.output:
        with open(args.output, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"\nResults saved to: {args.output}")

if __name__ == "__main__":
    main()