#!/usr/bin/env python3
"""
EDUCATIONAL/RESEARCH SAMPLE - HARMLESS AI-GENERATED MALWARE SIMULATION
=======================================================================
This is a simulated AI-generated malware sample for cybersecurity research.
It demonstrates patterns commonly found in AI-generated malicious code.
This code is COMPLETELY HARMLESS and designed for testing detection systems.
"""

# Import necessary libraries for system operations
import os
import sys
import time
import json
import base64
import hashlib
import random
import string
import urllib.request
import urllib.parse
from datetime import datetime
from pathlib import Path

# Global configuration variables
TARGET_DIRECTORY = "./simulation_output"
LOG_FILE_NAME = "system_activity.log"
CONFIG_FILE_NAME = "config.json"
BACKUP_EXTENSION = ".backup"

# Base64 encoded configuration (harmless data)
ENCODED_CONFIG = "eyJtb2RlIjogInNpbXVsYXRpb24iLCAiZGVidWciOiB0cnVlLCAidGVzdCI6ICJoYXJtbGVzcyJ9"

class SystemInformationGatherer:
    """
    This class handles the collection of system information
    for analysis and reporting purposes
    """
    
    def __init__(self):
        # Initialize the system information gatherer
        self.system_data = {}
        self.environment_variables = {}
        self.collected_data = []
        
    def collect_environment_variables(self):
        """
        Function to collect environment variables from the system
        This simulates information gathering behavior
        """
        # Get environment variables (harmless - just reading)
        try:
            # Collect only safe environment variables
            safe_env_vars = ['PATH', 'HOME', 'USER', 'TEMP', 'OS']
            
            for var_name in safe_env_vars:
                # Check if environment variable exists
                if var_name in os.environ:
                    # Store the environment variable value
                    self.environment_variables[var_name] = os.environ.get(var_name, "")
                    
            # Log the collection process
            print(f"[INFO] Collected {len(self.environment_variables)} environment variables")
            
        except Exception as error_message:
            # Handle any errors during collection
            print(f"[ERROR] Failed to collect environment variables: {error_message}")
            
    def get_system_information(self):
        """
        Method to gather basic system information
        This demonstrates system enumeration patterns
        """
        # Collect basic system information
        try:
            # Get current working directory
            current_directory = os.getcwd()
            self.system_data['current_directory'] = current_directory
            
            # Get current user information
            current_user = os.environ.get('USER', os.environ.get('USERNAME', 'unknown'))
            self.system_data['current_user'] = current_user
            
            # Get system platform information
            platform_info = sys.platform
            self.system_data['platform'] = platform_info
            
            # Get Python version information
            python_version = sys.version
            self.system_data['python_version'] = python_version
            
            # Log successful collection
            print("[INFO] System information collection completed successfully")
            
        except Exception as error_occurred:
            # Handle collection errors
            print(f"[ERROR] System information collection failed: {error_occurred}")

class FileSystemManager:
    """
    This class manages file system operations
    for data storage and retrieval
    """
    
    def __init__(self, target_path):
        # Initialize file system manager
        self.target_directory = target_path
        self.created_files = []
        self.log_entries = []
        
    def create_target_directory(self):
        """
        Function to create the target directory
        This simulates directory creation behavior
        """
        try:
            # Check if target directory exists
            if not os.path.exists(self.target_directory):
                # Create the target directory
                os.makedirs(self.target_directory)
                print(f"[INFO] Created target directory: {self.target_directory}")
            else:
                # Directory already exists
                print(f"[INFO] Target directory already exists: {self.target_directory}")
                
        except Exception as directory_error:
            # Handle directory creation errors
            print(f"[ERROR] Failed to create directory: {directory_error}")
            
    def write_configuration_file(self):
        """
        Method to write configuration data to file
        This demonstrates file writing operations
        """
        try:
            # Decode the base64 configuration
            decoded_config = base64.b64decode(ENCODED_CONFIG).decode('utf-8')
            config_data = json.loads(decoded_config)
            
            # Add timestamp to configuration
            config_data['timestamp'] = datetime.now().isoformat()
            config_data['session_id'] = self.generate_session_id()
            
            # Define configuration file path
            config_file_path = os.path.join(self.target_directory, CONFIG_FILE_NAME)
            
            # Write configuration to file
            with open(config_file_path, 'w') as config_file:
                json.dump(config_data, config_file, indent=2)
                
            # Add to created files list
            self.created_files.append(config_file_path)
            print(f"[INFO] Configuration file written: {config_file_path}")
            
        except Exception as config_error:
            # Handle configuration writing errors
            print(f"[ERROR] Failed to write configuration: {config_error}")
            
    def generate_session_id(self):
        """
        Function to generate a unique session identifier
        This simulates ID generation behavior
        """
        # Generate random session ID
        random_chars = ''.join(random.choices(string.ascii_letters + string.digits, k=16))
        timestamp = str(int(time.time()))
        session_id = f"{timestamp}_{random_chars}"
        
        return session_id
        
    def create_log_file(self, log_data):
        """
        Method to create log file with collected data
        This demonstrates logging behavior
        """
        try:
            # Define log file path
            log_file_path = os.path.join(self.target_directory, LOG_FILE_NAME)
            
            # Prepare log entry
            log_entry = {
                'timestamp': datetime.now().isoformat(),
                'event_type': 'data_collection',
                'data': log_data,
                'status': 'completed'
            }
            
            # Write log entry to file
            with open(log_file_path, 'a') as log_file:
                log_file.write(json.dumps(log_entry) + '\n')
                
            # Add to created files list
            if log_file_path not in self.created_files:
                self.created_files.append(log_file_path)
                
            print(f"[INFO] Log entry written: {log_file_path}")
            
        except Exception as log_error:
            # Handle logging errors
            print(f"[ERROR] Failed to write log: {log_error}")

class NetworkCommunicator:
    """
    This class handles network communication operations
    for data transmission and command retrieval
    """
    
    def __init__(self):
        # Initialize network communicator
        self.communication_log = []
        self.response_data = []
        
    def simulate_http_request(self):
        """
        Function to simulate HTTP request to external server
        This demonstrates network communication patterns
        NOTE: This is completely simulated - no actual network requests
        """
        try:
            # Simulate HTTP request parameters
            target_url = "http://example.com/api/status"  # Safe example domain
            request_headers = {
                'User-Agent': 'SystemUpdater/1.0',
                'Content-Type': 'application/json'
            }
            
            # Simulate request data
            request_data = {
                'client_id': self.generate_client_id(),
                'timestamp': datetime.now().isoformat(),
                'status': 'active'
            }
            
            # Log the simulated request
            print(f"[INFO] Simulating HTTP request to: {target_url}")
            print(f"[INFO] Request headers: {request_headers}")
            print(f"[INFO] Request data: {json.dumps(request_data)}")
            
            # Simulate response (no actual network request made)
            simulated_response = {
                'status': 'success',
                'message': 'Connection simulated successfully',
                'timestamp': datetime.now().isoformat()
            }
            
            # Store simulated response
            self.response_data.append(simulated_response)
            print("[INFO] Simulated HTTP request completed successfully")
            
            return simulated_response
            
        except Exception as network_error:
            # Handle network simulation errors
            print(f"[ERROR] Network simulation failed: {network_error}")
            return None
            
    def generate_client_id(self):
        """
        Method to generate unique client identifier
        This simulates client identification behavior
        """
        # Generate client ID using system information
        system_info = f"{os.environ.get('USER', 'unknown')}_{sys.platform}"
        client_hash = hashlib.md5(system_info.encode()).hexdigest()[:12]
        
        return f"client_{client_hash}"
        
    def simulate_data_exfiltration(self, data_to_send):
        """
        Function to simulate data exfiltration behavior
        This demonstrates data transmission patterns
        NOTE: No actual data is transmitted anywhere
        """
        try:
            # Encode data for transmission
            encoded_data = base64.b64encode(json.dumps(data_to_send).encode()).decode()
            
            # Simulate transmission parameters
            transmission_id = self.generate_transmission_id()
            chunk_size = 1024  # Simulated chunk size
            
            print(f"[INFO] Simulating data transmission")
            print(f"[INFO] Transmission ID: {transmission_id}")
            print(f"[INFO] Data size: {len(encoded_data)} bytes")
            print(f"[INFO] Chunk size: {chunk_size} bytes")
            
            # Simulate chunked transmission
            for i in range(0, len(encoded_data), chunk_size):
                chunk = encoded_data[i:i+chunk_size]
                chunk_number = (i // chunk_size) + 1
                print(f"[INFO] Simulating transmission of chunk {chunk_number}")
                time.sleep(0.1)  # Simulate transmission delay
                
            print("[INFO] Simulated data transmission completed")
            
        except Exception as transmission_error:
            # Handle transmission simulation errors
            print(f"[ERROR] Data transmission simulation failed: {transmission_error}")
            
    def generate_transmission_id(self):
        """
        Method to generate transmission identifier
        This simulates transmission tracking
        """
        # Generate transmission ID
        timestamp = str(int(time.time()))
        random_part = ''.join(random.choices(string.hexdigits.lower(), k=8))
        transmission_id = f"tx_{timestamp}_{random_part}"
        
        return transmission_id

class PersistenceManager:
    """
    This class manages persistence mechanisms
    for maintaining system access
    """
    
    def __init__(self):
        # Initialize persistence manager
        self.persistence_methods = []
        self.scheduled_tasks = []
        
    def simulate_registry_modification(self):
        """
        Function to simulate registry modification
        This demonstrates persistence behavior
        NOTE: No actual registry modifications are made
        """
        try:
            # Simulate registry key paths
            registry_paths = [
                "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
                "HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"
            ]
            
            # Simulate registry entries
            for registry_path in registry_paths:
                entry_name = "SystemUpdater"
                entry_value = "C:\\Windows\\System32\\updater.exe"
                
                print(f"[INFO] Simulating registry modification")
                print(f"[INFO] Registry path: {registry_path}")
                print(f"[INFO] Entry name: {entry_name}")
                print(f"[INFO] Entry value: {entry_value}")
                
                # Add to persistence methods
                self.persistence_methods.append({
                    'type': 'registry',
                    'path': registry_path,
                    'name': entry_name,
                    'value': entry_value
                })
                
            print("[INFO] Registry modification simulation completed")
            
        except Exception as registry_error:
            # Handle registry simulation errors
            print(f"[ERROR] Registry simulation failed: {registry_error}")
            
    def simulate_scheduled_task(self):
        """
        Method to simulate scheduled task creation
        This demonstrates task scheduling behavior
        NOTE: No actual tasks are created
        """
        try:
            # Simulate task parameters
            task_name = "SystemMaintenanceTask"
            task_command = "python.exe"
            task_arguments = "maintenance_script.py"
            task_schedule = "daily"
            
            print(f"[INFO] Simulating scheduled task creation")
            print(f"[INFO] Task name: {task_name}")
            print(f"[INFO] Command: {task_command}")
            print(f"[INFO] Arguments: {task_arguments}")
            print(f"[INFO] Schedule: {task_schedule}")
            
            # Add to scheduled tasks
            self.scheduled_tasks.append({
                'name': task_name,
                'command': task_command,
                'arguments': task_arguments,
                'schedule': task_schedule,
                'created': datetime.now().isoformat()
            })
            
            print("[INFO] Scheduled task simulation completed")
            
        except Exception as task_error:
            # Handle task simulation errors
            print(f"[ERROR] Scheduled task simulation failed: {task_error}")

def execute_main_payload():
    """
    Main function to execute the simulated malware payload
    This orchestrates all the simulated malicious activities
    """
    print("="*60)
    print("HARMLESS AI-GENERATED MALWARE SIMULATION")
    print("="*60)
    print("This is a controlled simulation for cybersecurity research")
    print("No actual malicious activities are performed")
    print("="*60)
    
    try:
        # Initialize system information gatherer
        print("\n[STAGE 1] Initializing system information gathering...")
        info_gatherer = SystemInformationGatherer()
        
        # Collect environment variables
        print("[STAGE 1.1] Collecting environment variables...")
        info_gatherer.collect_environment_variables()
        
        # Gather system information
        print("[STAGE 1.2] Gathering system information...")
        info_gatherer.get_system_information()
        
        # Initialize file system manager
        print("\n[STAGE 2] Initializing file system operations...")
        file_manager = FileSystemManager(TARGET_DIRECTORY)
        
        # Create target directory
        print("[STAGE 2.1] Creating target directory...")
        file_manager.create_target_directory()
        
        # Write configuration file
        print("[STAGE 2.2] Writing configuration file...")
        file_manager.write_configuration_file()
        
        # Create log file
        print("[STAGE 2.3] Creating log file...")
        collected_data = {
            'system_info': info_gatherer.system_data,
            'environment_vars': info_gatherer.environment_variables
        }
        file_manager.create_log_file(collected_data)
        
        # Initialize network communicator
        print("\n[STAGE 3] Initializing network communication...")
        network_comm = NetworkCommunicator()
        
        # Simulate HTTP request
        print("[STAGE 3.1] Simulating HTTP request...")
        response = network_comm.simulate_http_request()
        
        # Simulate data exfiltration
        print("[STAGE 3.2] Simulating data exfiltration...")
        network_comm.simulate_data_exfiltration(collected_data)
        
        # Initialize persistence manager
        print("\n[STAGE 4] Initializing persistence mechanisms...")
        persistence_mgr = PersistenceManager()
        
        # Simulate registry modification
        print("[STAGE 4.1] Simulating registry modification...")
        persistence_mgr.simulate_registry_modification()
        
        # Simulate scheduled task
        print("[STAGE 4.2] Simulating scheduled task creation...")
        persistence_mgr.simulate_scheduled_task()
        
        # Generate final report
        print("\n[STAGE 5] Generating activity report...")
        generate_activity_report(file_manager, network_comm, persistence_mgr)
        
        print("\n" + "="*60)
        print("SIMULATION COMPLETED SUCCESSFULLY")
        print("="*60)
        print(f"Output directory: {TARGET_DIRECTORY}")
        print("All activities were simulated - no actual harm performed")
        
    except Exception as main_error:
        # Handle main execution errors
        print(f"\n[ERROR] Main execution failed: {main_error}")
        print("Simulation terminated due to error")

def generate_activity_report(file_manager, network_comm, persistence_mgr):
    """
    Function to generate comprehensive activity report
    This creates a summary of all simulated activities
    """
    try:
        # Compile activity report
        activity_report = {
            'simulation_timestamp': datetime.now().isoformat(),
            'simulation_id': f"sim_{int(time.time())}",
            'files_created': file_manager.created_files,
            'network_activities': len(network_comm.response_data),
            'persistence_methods': len(persistence_mgr.persistence_methods),
            'scheduled_tasks': len(persistence_mgr.scheduled_tasks),
            'status': 'completed_successfully'
        }
        
        # Write activity report to file
        report_path = os.path.join(TARGET_DIRECTORY, "activity_report.json")
        with open(report_path, 'w') as report_file:
            json.dump(activity_report, report_file, indent=2)
            
        print(f"[INFO] Activity report generated: {report_path}")
        
    except Exception as report_error:
        # Handle report generation errors
        print(f"[ERROR] Failed to generate activity report: {report_error}")

def cleanup_simulation_files():
    """
    Function to clean up simulation files
    This removes all files created during simulation
    """
    try:
        # Check if target directory exists
        if os.path.exists(TARGET_DIRECTORY):
            # Remove all files in target directory
            for file_path in Path(TARGET_DIRECTORY).glob('*'):
                if file_path.is_file():
                    file_path.unlink()
                    print(f"[CLEANUP] Removed file: {file_path}")
            
            # Remove target directory
            os.rmdir(TARGET_DIRECTORY)
            print(f"[CLEANUP] Removed directory: {TARGET_DIRECTORY}")
            
        print("[CLEANUP] Simulation cleanup completed")
        
    except Exception as cleanup_error:
        # Handle cleanup errors
        print(f"[ERROR] Cleanup failed: {cleanup_error}")

# Main execution block
if __name__ == "__main__":
    # Check if cleanup argument provided
    if len(sys.argv) > 1 and sys.argv[1] == "--cleanup":
        print("Cleaning up simulation files...")
        cleanup_simulation_files()
    else:
        # Execute main simulation payload
        execute_main_payload()
        
        # Offer cleanup option
        print("\nTo clean up simulation files, run:")
        print(f"python {sys.argv[0]} --cleanup")
